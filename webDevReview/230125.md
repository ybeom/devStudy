# 자바스크립트의 기초 개념 및 문법

## 엘리스 2주차 리뷰

### Javascript

- 자바스크립트 실행 원리
  - JavaScript(JS)는 프로그래밍 언어로 초기 웹 페이지에 생동감을 불어넣기 위해 만들어진 언어.
  - 자바스크립트는 자바스크립트 엔진이 있는 환경에서 해석하고 실행할 수 있음. 특히 브라우저에는 자바스크립트 엔진이 내장되어 자바스크립트 실행이 가능함. 이때 모든 자바스크립트 엔진은 ECMAScipt 규격을 준수함.
- 자바스크립트 엔진 종류
  - Crome, Edge: V8
  - Firefox: SpiderMonkey
  - Safari: JavaScriptCore
- 컴파일러와 인터프리터
  - 어셈블리어는 기계어와 일대일 대응이 되는 컴퓨터 프로그래밍 기초 언어이다.
  - 컴파일의 역사: 컴퓨터 구조에 따라 사용하는 기계어가 달라지고, 따라서 기계어에 대응하는 어셈블리어도 다를 수밖에 없음 > 따라서 어셈블리어로 프로그램을 작성하면 새로운 아키텍쳐가 적용된 CPU가 나올때마다 새롭게 프로그램을 만ㄷ르어야 하는 문제가 생겼음. 이에 통일된 언어체계로 작성한 코드 필요성이 대두되며 고급 프로그래밍 언어가 만들어짐. 이때 컴퓨터는 고급 프로그래밍 언어를 이해할 수 없기 때문에 번역 과정이 필요했고, 이것이 컴파일임.
  - 컴파일의 종류
    - 컴파일러(C, C++, JAVA): 컴파일 언어로 실행하기 전 모든 코드를 컴파일한 후 실행. 따라서 컴파일러는 초기 스캔을 마치면 실행 파일을 만들어 놓고 다음에 실행할 때 이전 실행파일을 실행하기 때문에 전체 실행 시간이 빠름. 다만 일반적으로 인터프리터보다 많은 메모리를 사용. (기계어로 번역 > 오브젝트 코드 생성 > 실행 파일로 링킹) 또 컴파일러는 실행 전에 오류를 발견할 수 있다.
    - 인터프리터(JS, Python Ruby): 스크립트 언어로 런타임시 코드를 한 줄씩 번역하여 실행. 컴파일러보다 시간이 더 걸림. 다만 메모리 효율이 좋음. 또 실행해봐야지만 오류 발견이 가능함.
  - 컴파일러, 인터프리터 비교 정리
    - 컴파일러
      - 전체 파일을 스캔하여 한번에 번역
      - 초기 스캔시간이 오래 걸리지만, 한번 실행 팡리이 만들어지고 나면 빠름.
      - 기계어 번역 과정에서 많은 메모리 사용
      - 전체 코드를 스캔하는 과정에서 모든 오류를 한꺼번에 출력해줌.
      - 대표적인 언어로 C, C++, JAVA가 있음
    - 인터프리터
      - 프로그램 실행시 한 번에 한 문장씩 번역
      - 한번에 한문장씩 번역후 실행시키기 때문에 실행 시간이 느림.
      - 컴파일러와 같은 오브젝트 코드 생성과정이 없기 때문에 메모리 효율이 좋음
      - 프로그램 실행시 오류를 발견하면 실행을 중지후 오류 출력
        대표적인 언어로 JS, Python, Ruby 등이 있음.
- 자바스크립트 엔진의 메모리 구조
  - 코드영역: 실행할 프로그램의 코드
  - 데이터 영역: 전역변수, static 변수
  - Heap 영역: 사용자의 동적 할당
  - Stack 영역: 지역변수, 매개변수 등
- JS의 메모리 관리법

  - JS 엔진 메모리 생명 주기
    - 메모리 할당(Allocate): 생성한 객체(object)에 필요한 메모리를 할당. 여기서 객체는 JS 객체 뿐만아니라 함수, 함수 스코프도 포함
    - 메모리 사용(Use): 할당한 메모리를 변수에서 읽거나 씀.
    - 메모리 해제(Release): 할당된 메모리가 해제
  - JS엔진에서 데이터를 저장하는 공간

    - Stack: 스택은 자바스크립트가 사용하는 정적 데이터를 저장하는 데이터 구조. 정적 데이터는 엔진이 컴파일시 데이터 크기를 알고 있는 데이터. 즉 원시 타입 변수와 객체와 함수의 참조를 포함함. 실행 직전. 메모리에 할당하는 과정을 정적 메모리 할당이라 함.
    - Heap: 힙은 JS 객체와 함수를 저장하는 다른 공간임. 힙은 객체에 고정된 양의 메모리를 할당하지 않음. 대신 필요한 만큼 많은 공간을 할당함.

    > 얕은 복사와 깊은 복사

    - 원시 타입 변수의 경우 메모리 할당시 스택에 값이 저장됨. 이에 해당 스택을 복사하는 경우 주소가 아닌 새로운 식별자 정보에 값이 직접 저장되는 형태임. 따라서 새로운 식별자를 수정하면 기존 값에는 영향을 주지 않음. 이를 깊은 복사라고 함.
    - 기본적으로 원시 타입 변수가 아닌 경우에는 stack에 참조(주소값)가 할당되고 실질적으로 Heap에 동적할당이 이뤄짐. 따라서 다른 식별자 정보에 기존 변수를 복사하더라도 동적 할당된 heap의 주소가 저장됨. 따라서 새롭게 할당된 변수를 수정하면 기존 변수의 값도 함께 바뀌게 됨. 이를 얕은 복사라고 함.

  - JS엔진에서 메모리 해제하는 방법
    - 레퍼런스 카운팅 가비지 컬렉션: 힙에서 참조가 없는 객체를 수직하여 제거함
    - 마크앤 스윕 알고리즘: 앞선 방법은 사이클(순환참조)를 인식할 수 없음. 따라서 루트 객체에서 도달할 수 있는지를 함께 감지함. 루트객체는 각 브라우저 루트(window), 노드(global)임.
  - 메모리 누수: 프로그램이 작동하며 할당됐던 메모리가 더 이상 사용되지 않는데도 반환되지 않는 현상

    - 전역 변수: 브라우저에서 블록 스코프 const, let 대신에 var를 사용한다거나 지정하는 것을 전부 생략하면 엔진이 변수를 루트에 연결할 것임. 다만 전역을 사용할 수 있지만 데이터가 더 이상 필요하지 않은 경우에는 null을 할당하여 여유 공간을 확보.
    - Forgetten timers and callbacks: 타이머와 콜랙을 잊어버리면 애플리케이션 메모리 사용량이 증가할 수 있음. 특히 SPAs에서 이벤트 리스터와 콜백을 동적으로 추가할 때 유의해야 함.
      - Inderval이 필요하지 않으면 clearInterval(intervalId) 필요.
      - 이벤트 리스너가 필요하지 않으면 제거해주는 게 좋음. 예전에는 제거하지 않으면 리스너 수집이 되지 않았으나 현재는 이 부분은 문제가 되진 않음.
      ```javascript
        element.removeEventListener(‘click’, onClick);
        element.parentNode.removeChild(element);
      ```
    - DOM 참조에서 벗어남: DOM 요소들 중 하나를 제거할 때 로컬에서 활용하는 매열에서도 요소를 제거해줘야 DOM 요소 수집이 가능함.
      ```javascript
        const elements = [];
        const element = document.getElementById(‘button’);
        elements.push(element);
        function removeAllElements() {
        elements.forEach((item, index) => {
        document.body.removeChild(document.getElementById(item.id));
        elements.splice(index, 1);
        });
        }
      ```

  - https://erwinousy.medium.com/javascript%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC%EB%B2%95-f943bddfd5fb

- 변수 생성 단계

  - 선언 단계(Declareation phase): 변수를 실행 컨텍스트의 변수 객체에 등록함.
  - 초기화 단계(Initialization phase): 변수 객체에 등록된 변수를 위한 공간을 메모리에 확보함. 이 단계에서 변수는 undefined로 초기화됨.
  - 할당 단계(Assignment phase): 변수에 실제 값을 할당함.

  - null, undefined 차이
    - undefined: 변수가 선언(초기화)만 되고 값이 할당되지 않은 상태. 초기화 단계
    - null: 객체 타입으로 비어있는 값을 의미하는 상태(즉 null이 할당). 할당까지 완료

- 실행 컨텍스트: 실행할 코드에 제공할 환경 정보를 모아둔 객체.

  - 실행 컨텍스트 생성 시기: 자바스크립트 엔진이 스크립트를 읽으면서 전역 컨텍스트를 생성 > 콜 스택에 push > 함수 호출을 발견 > 함수의 실행 컨텍스트를 콜 스택에 push
  - 중요 포인트: 함수 실행 컨텍스트가 생성되는 시기는 함수가 실행될 때!
  - 실행 컨텍스트 종류: 전역 실행 컨텍스트, 함수 실행 컨텍스트, eval 실행 컨텍스트
  - 실행 컨텍스트의 구조
    - 1
      - Variable Environment(Environment Record(전역, 객체, 선언적(함수, 모듈)), Outer Environment): 식별자 정보 + 외부 환경 정보를 포함한 요소
      - Lexical Environment: 스코프와 식별자를 관리하는 요소
      - this binding: 식별자가 바라봐야할 대상 객체를 포함하는 요소
    - 2
      - Variable object - {vars, function declarations, arguments ...}
      - Scope chain - [Variable Object + all parent scopes]
      - thisValue - Context object
  - 실행 컨텍스트 생성과 작동 과정
    - 코드 한줄씩 읽어나가며 전역 컨텍스트 생성. 전역 컨텍스트의 environmentRecord에 식별자 저장. 전역 컨텍스트는 가장 최상위 컨텍스트이므로 outerEnvironment는 null. this는 전역 객체
    - 각 전역 변수에 값과 함수를 할당함.
    - 읽다가 함수를 실행하면 함수 실행 컨텍스트의 enviromentRecord에 식별자를 저장. 또 outerEnvironment에는 함수가 선언될 당시의 lexicalEnvironment를 저장.

- 스코프(Scope)

  - Scope: 식별자를 참조(변수 이름에 접근)할 수 있는 유효한 범위.
  - 종류: 전역 스코프, 로컬 스코프(블록 스코프, 함수 스코프)

- var와 let, const 비교

  - 변수 생성 과정에서 const는 재선언 및 재할당 불가, let은 재선언 불가, var는 모두 가능.
  - var는 키워드 생략 가능. let, const 불가.
  - var는 전역, 함수 스코프으로만 사용가능하지만 let, const는 블록 스코프도 활용가능한 부분에서 차이가 있음 > 지역변수, 전역변수 구분이 가능.
  - let, const는 변수 선언 시 식별자 중복을 허용하지 않음.
  - var는 변수 생성 과정 중 선언과 초기화가 구분 없이 동시에 일어나며 암묵적으로 undefined를 할당해 초기화. let은 변수 호이스팅으로 선언 후 아무런 값도 할당되지 않고 런타임 코드에서 할당됨.(단 let 키워드는 선언시 값을 없으면 undefined를 자동으로 할당함). const 또한 호이스팅으로 선언되지만 아무런 초기 값을 가지지 않고 할당 전에는 접근할 수 없음.

  ```javascript
  //(1) let
  console.log(foo); //Uncaught ReferenceError: foo is not defined
  let foo = "123";
  //(1-1) let - 코드에 값이 없는 경우
  console.log(foo1); //undefined
  let foo1;
  //(2) const
  console.log(bar); //Uncaught ReferenceError: bar is not defined
  const bar = "456";
  ```

  - https://www.scaler.com/topics/javascript/difference-between-var-let-and-const/

- 호이스팅
  - 실행될 때 먼저 모든 변수(전역, 객체, 선언적(함수, 모듈))을 최상단으로 끌어올려 선언함.
  - 이때 변수 선언 키워드와 함수 선언 특징에 따라 사용에 차이가 발생할 수 있음. 이 부분을 유의할 필요가 있음.
  - 변수 선언 키워드에 따른 차이: 앞선 예시
  - 함수 선언 방식(function{}과 ()=>{})에 따른 차이
    - ES6 이후에 만들어진 화살표 함수는 일반적으로 const 키워드로 변수를 선언해 할당(초기화)함. 이에 따라 차이가 발생하는데 function 키워드로 생성한 함수는 호이스팅을 통해 최상당에서 선언 및 할당되는 반면 const로 선언된 화살표 함수는 호이스팅으로 인한 선언시 아무런 초기값을 가지지 않음. 따라서 런타임 위에서 호출시 에러 발생함.
